#include <bits/stdc++.h>
using namespace std;

typedef struct blok{
	int s[4][4];
}blok;

int rc[10] = { 
0x01,0x02,
0x04,0x08,
0x10,0x20,
0x40,0x80,
0x1b,0x36
};

int mix_arr[4][4]={
{2, 3, 1, 1},
{1, 2, 3, 1},
{1, 1, 2, 3},
{3, 1, 1, 2}
};

int inv_mix_arr[4][4]={
{14, 11, 13, 9},
{9, 14, 11, 13},
{13, 9, 14, 11},
{11, 13, 9, 14}
};

int sbox[16][16] =
 {0x63 ,0x7c ,0x77 ,0x7b ,0xf2 ,0x6b ,0x6f ,0xc5 ,0x30 ,0x01 ,0x67 ,0x2b ,0xfe ,0xd7 ,0xab ,0x76
 ,0xca ,0x82 ,0xc9 ,0x7d ,0xfa ,0x59 ,0x47 ,0xf0 ,0xad ,0xd4 ,0xa2 ,0xaf ,0x9c ,0xa4 ,0x72 ,0xc0
 ,0xb7 ,0xfd ,0x93 ,0x26 ,0x36 ,0x3f ,0xf7 ,0xcc ,0x34 ,0xa5 ,0xe5 ,0xf1 ,0x71 ,0xd8 ,0x31 ,0x15
 ,0x04 ,0xc7 ,0x23 ,0xc3 ,0x18 ,0x96 ,0x05 ,0x9a ,0x07 ,0x12 ,0x80 ,0xe2 ,0xeb ,0x27 ,0xb2 ,0x75
 ,0x09 ,0x83 ,0x2c ,0x1a ,0x1b ,0x6e ,0x5a ,0xa0 ,0x52 ,0x3b ,0xd6 ,0xb3 ,0x29 ,0xe3 ,0x2f ,0x84
 ,0x53 ,0xd1 ,0x00 ,0xed ,0x20 ,0xfc ,0xb1 ,0x5b ,0x6a ,0xcb ,0xbe ,0x39 ,0x4a ,0x4c ,0x58 ,0xcf
 ,0xd0 ,0xef ,0xaa ,0xfb ,0x43 ,0x4d ,0x33 ,0x85 ,0x45 ,0xf9 ,0x02 ,0x7f ,0x50 ,0x3c ,0x9f ,0xa8
 ,0x51 ,0xa3 ,0x40 ,0x8f ,0x92 ,0x9d ,0x38 ,0xf5 ,0xbc ,0xb6 ,0xda ,0x21 ,0x10 ,0xff ,0xf3 ,0xd2
 ,0xcd ,0x0c ,0x13 ,0xec ,0x5f ,0x97 ,0x44 ,0x17 ,0xc4 ,0xa7 ,0x7e ,0x3d ,0x64 ,0x5d ,0x19 ,0x73
 ,0x60 ,0x81 ,0x4f ,0xdc ,0x22 ,0x2a ,0x90 ,0x88 ,0x46 ,0xee ,0xb8 ,0x14 ,0xde ,0x5e ,0x0b ,0xdb
 ,0xe0 ,0x32 ,0x3a ,0x0a ,0x49 ,0x06 ,0x24 ,0x5c ,0xc2 ,0xd3 ,0xac ,0x62 ,0x91 ,0x95 ,0xe4 ,0x79
 ,0xe7 ,0xc8 ,0x37 ,0x6d ,0x8d ,0xd5 ,0x4e ,0xa9 ,0x6c ,0x56 ,0xf4 ,0xea ,0x65 ,0x7a ,0xae ,0x08
 ,0xba ,0x78 ,0x25 ,0x2e ,0x1c ,0xa6 ,0xb4 ,0xc6 ,0xe8 ,0xdd ,0x74 ,0x1f ,0x4b ,0xbd ,0x8b ,0x8a
 ,0x70 ,0x3e ,0xb5 ,0x66 ,0x48 ,0x03 ,0xf6 ,0x0e ,0x61 ,0x35 ,0x57 ,0xb9 ,0x86 ,0xc1 ,0x1d ,0x9e
 ,0xe1 ,0xf8 ,0x98 ,0x11 ,0x69 ,0xd9 ,0x8e ,0x94 ,0x9b ,0x1e ,0x87 ,0xe9 ,0xce ,0x55 ,0x28 ,0xdf
 ,0x8c ,0xa1 ,0x89 ,0x0d ,0xbf ,0xe6 ,0x42 ,0x68 ,0x41 ,0x99 ,0x2d ,0x0f ,0xb0 ,0x54 ,0xbb ,0x16};
 
int isbox[16][16] =
 {0x52 ,0x09 ,0x6a ,0xd5 ,0x30 ,0x36 ,0xa5 ,0x38 ,0xbf ,0x40 ,0xa3 ,0x9e ,0x81 ,0xf3 ,0xd7 ,0xfb
 ,0x7c ,0xe3 ,0x39 ,0x82 ,0x9b ,0x2f ,0xff ,0x87 ,0x34 ,0x8e ,0x43 ,0x44 ,0xc4 ,0xde ,0xe9 ,0xcb
 ,0x54 ,0x7b ,0x94 ,0x32 ,0xa6 ,0xc2 ,0x23 ,0x3d ,0xee ,0x4c ,0x95 ,0x0b ,0x42 ,0xfa ,0xc3 ,0x4e
 ,0x08 ,0x2e ,0xa1 ,0x66 ,0x28 ,0xd9 ,0x24 ,0xb2 ,0x76 ,0x5b ,0xa2 ,0x49 ,0x6d ,0x8b ,0xd1 ,0x25
 ,0x72 ,0xf8 ,0xf6 ,0x64 ,0x86 ,0x68 ,0x98 ,0x16 ,0xd4 ,0xa4 ,0x5c ,0xcc ,0x5d ,0x65 ,0xb6 ,0x92
 ,0x6c ,0x70 ,0x48 ,0x50 ,0xfd ,0xed ,0xb9 ,0xda ,0x5e ,0x15 ,0x46 ,0x57 ,0xa7 ,0x8d ,0x9d ,0x84
 ,0x90 ,0xd8 ,0xab ,0x00 ,0x8c ,0xbc ,0xd3 ,0x0a ,0xf7 ,0xe4 ,0x58 ,0x05 ,0xb8 ,0xb3 ,0x45 ,0x06
 ,0xd0 ,0x2c ,0x1e ,0x8f ,0xca ,0x3f ,0x0f ,0x02 ,0xc1 ,0xaf ,0xbd ,0x03 ,0x01 ,0x13 ,0x8a ,0x6b
 ,0x3a ,0x91 ,0x11 ,0x41 ,0x4f ,0x67 ,0xdc ,0xea ,0x97 ,0xf2 ,0xcf ,0xce ,0xf0 ,0xb4 ,0xe6 ,0x73
 ,0x96 ,0xac ,0x74 ,0x22 ,0xe7 ,0xad ,0x35 ,0x85 ,0xe2 ,0xf9 ,0x37 ,0xe8 ,0x1c ,0x75 ,0xdf ,0x6e
 ,0x47 ,0xf1 ,0x1a ,0x71 ,0x1d ,0x29 ,0xc5 ,0x89 ,0x6f ,0xb7 ,0x62 ,0x0e ,0xaa ,0x18 ,0xbe ,0x1b
 ,0xfc ,0x56 ,0x3e ,0x4b ,0xc6 ,0xd2 ,0x79 ,0x20 ,0x9a ,0xdb ,0xc0 ,0xfe ,0x78 ,0xcd ,0x5a ,0xf4
 ,0x1f ,0xdd ,0xa8 ,0x33 ,0x88 ,0x07 ,0xc7 ,0x31 ,0xb1 ,0x12 ,0x10 ,0x59 ,0x27 ,0x80 ,0xec ,0x5f
 ,0x60 ,0x51 ,0x7f ,0xa9 ,0x19 ,0xb5 ,0x4a ,0x0d ,0x2d ,0xe5 ,0x7a ,0x9f ,0x93 ,0xc9 ,0x9c ,0xef
 ,0xa0 ,0xe0 ,0x3b ,0x4d ,0xae ,0x2a ,0xf5 ,0xb0 ,0xc8 ,0xeb ,0xbb ,0x3c ,0x83 ,0x53 ,0x99 ,0x61
 ,0x17 ,0x2b ,0x04 ,0x7e ,0xba ,0x77 ,0xd6 ,0x26 ,0xe1 ,0x69 ,0x14 ,0x63 ,0x55 ,0x21 ,0x0c ,0x7d
 };

void get_key(blok *key)
{
	int c;
	ifstream fin;
	fin.open("key.txt");
	for(int j=0; j<4; j++)
		for(int k=0; k<4; k++)
		{
			fin >> hex >> c;
			key[0].s[j][k]=c;
		}
	fin.close();
	
	for(int i=1; i<11; i++)
	{
		int g[4];
		// shift left and sub column key kolom - 3 untuk mendapat g
		for(int j=0; j<4; j++)
		{
			if(j<3)
				g[j] = sbox[key[i-1].s[j+1][3]/16][key[i-1].s[j+1][3]%16];
			else
				g[j] = sbox[key[i-1].s[0][3]/16][key[i-1].s[0][3]%16]; 
		}
		g[0] = g[0]^rc[i-1];
		
		// untuk kolom ke-0
		for(int j=0; j<4; j++)
			key[i].s[j][0] = key[i-1].s[j][0]^g[j];
						
		// kolom-1 sampai kolom-3
		for(int k=1; k<4; k++)
			for(int j=0; j<4; j++)
				key[i].s[j][k] = key[i-1].s[j][k]^key[i].s[j][k-1];
	}
}

const int of = 0x100, m = 0x11B;
int gf_mul(int a, int b) {
    int sum = 0;
    while (b > 0) {
        if (b & 1) sum = sum ^ a;             
        b = b >> 1;                           
        a = a << 1;                           
        if (a & of) a = a ^ m;    
    }
    return sum;
}

void sub_column(blok &bk)
{
	for(int j=0; j<4; j++)
		for(int k=0; k<4; k++)
			bk.s[j][k]=sbox[bk.s[j][k]/16][bk.s[j][k]%16];
		
}

void inv_sub_column(blok &bk)
{
	for(int j=0; j<4; j++)
		for(int k=0; k<4; k++)
			bk.s[j][k]=isbox[bk.s[j][k]/16][bk.s[j][k]%16];
}

void shift_row(blok &bk)
{
	int tmp;
	tmp=bk.s[1][0];
	bk.s[1][0] = bk.s[1][1]; 
	bk.s[1][1] = bk.s[1][2]; 
	bk.s[1][2] = bk.s[1][3];
	bk.s[1][3] = tmp;
		
	tmp=bk.s[2][0];
	bk.s[2][0] = bk.s[2][2]; 
	bk.s[2][2] = tmp; 
	tmp=bk.s[2][1];
	bk.s[2][1] = bk.s[2][3];
	bk.s[2][3] = tmp;
			
	tmp=bk.s[3][0];
	bk.s[3][0] = bk.s[3][3]; 
	bk.s[3][3] = bk.s[3][2]; 
	bk.s[3][2] = bk.s[3][1];
	bk.s[3][1] = tmp;
	
}

void inv_shift_row(blok &bk)
{
	int tmp;
	tmp=bk.s[3][0];
	bk.s[3][0] = bk.s[3][1]; 
	bk.s[3][1] = bk.s[3][2]; 
	bk.s[3][2] = bk.s[3][3];
	bk.s[3][3] = tmp;
		
	tmp=bk.s[2][0];
	bk.s[2][0] = bk.s[2][2]; 
	bk.s[2][2] = tmp; 
	tmp=bk.s[2][1];
	bk.s[2][1] = bk.s[2][3];
	bk.s[2][3] = tmp;
			
	tmp=bk.s[1][0];
	bk.s[1][0] = bk.s[1][3]; 
	bk.s[1][3] = bk.s[1][2]; 
	bk.s[1][2] = bk.s[1][1];
	bk.s[1][1] = tmp;
}

void mix_column(blok &bk)
{
	int arr_tmp[4];
	for(int k=0; k<4; k++)
	{
		// get column
		for(int j=0; j<4; j++)
			arr_tmp[j] = bk.s[j][k];
			
		// find each value of column k row j
		for(int j=0; j<4; j++)
		{
			bk.s[j][k]=
			gf_mul(arr_tmp[0],mix_arr[j][0])^gf_mul(arr_tmp[1],mix_arr[j][1])^
			gf_mul(arr_tmp[2],mix_arr[j][2])^gf_mul(arr_tmp[3],mix_arr[j][3]);
		}
	}
}

void inv_mix_column(blok &bk)
{
	int arr_tmp[4];
	for(int k=0; k<4; k++)
	{
		// get row
		for(int j=0; j<4; j++)
			arr_tmp[j] = bk.s[j][k];
			
		// find each value of column k row j
		for(int j=0; j<4; j++)
		{
			bk.s[j][k]=
			gf_mul(arr_tmp[0],inv_mix_arr[j][0])^gf_mul(arr_tmp[1],inv_mix_arr[j][1])^
			gf_mul(arr_tmp[2],inv_mix_arr[j][2])^gf_mul(arr_tmp[3],inv_mix_arr[j][3]);
		}
	}
}

void add_key(int x, blok &bk, blok *key)
{
	for(int j=0; j<4; j++)
		for(int k=0; k<4; k++)
			bk.s[j][k] = bk.s[j][k] ^ key[x].s[j][k];
}

void enkripsi(blok &bk, blok *key)
{
	add_key(0,bk,key);
	for(int i=1; i<=9; i++)
	{
		sub_column(bk);
		shift_row(bk);
		mix_column(bk);
		add_key(i,bk,key);
	}
	sub_column(bk);
	shift_row(bk);
	add_key(10,bk,key);
}

void dekripsi(blok &bk, blok *key)
{
	add_key(10,bk,key);
	for(int i=9; i>=1; i--)
	{
		inv_shift_row(bk);
		inv_sub_column(bk);
		add_key(i,bk, key);
		inv_mix_column(bk);
	}
	inv_shift_row(bk);
	inv_sub_column(bk);
	add_key(0,bk, key);

}

void print(blok bk)
{
	// output tes
	for(int j=0; j<4; j++)
		for(int k=0; k<4; k++)
			printf("%x ",bk.s[j][k]);
}

int main () 
{
	// blok key
	blok key[11];
	get_key(key);
	print(key[0]);
	
	int pilihan;
	system("CLS");
	printf("Daftar Pilihan : \n");
	printf("1. Enkripsi\n");
	printf("2. Dekripsi\n");
	printf("Masukkan Pilihan : ");
	scanf("%d",&pilihan);
	
	system("CLS");
	
	// blok chipper text
	blok bk;
	int cnt = 0;
	int c;
	
	ifstream fin;
	fin.open("file.txt");
	while (fin >> hex >> c)
	{
		bk.s[cnt/4][cnt%4]=c;
		cnt++;
		
		if(cnt == 16)
		{
			if(pilihan == 1)
				enkripsi(bk, key);
			else
				dekripsi(bk, key);
			print(bk);
			cnt = 0;
		}
	}
	fin.close();
	
	if(cnt > 0)
	{
		for(; cnt<=16; cnt++) 
			bk.s[cnt/4][cnt%4]=' ';
	
		if(pilihan == 1)
			enkripsi(bk, key);
		else
			dekripsi(bk, key);
		print(bk);
		cnt = 0;
	}

  return 0;
}
