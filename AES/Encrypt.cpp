#include <bits/stdc++.h>
using namespace std;

typedef struct blok{
	int s[4][4];
}blok;

// blok holder
vector<blok> v_blok;
blok key;

int mix_arr[4][4]={
{2, 3, 1, 1},
{1, 2, 3, 1},
{1, 1, 2, 3},
{3, 1, 1, 2}
};

int inv_mix_arr[4][4]={
{14, 11, 13, 9},
{9, 14, 11, 13},
{13, 9, 14, 11},
{11, 13, 9, 14}
};

int sbox[16][16] =
 {0x63 ,0x7c ,0x77 ,0x7b ,0xf2 ,0x6b ,0x6f ,0xc5 ,0x30 ,0x01 ,0x67 ,0x2b ,0xfe ,0xd7 ,0xab ,0x76
 ,0xca ,0x82 ,0xc9 ,0x7d ,0xfa ,0x59 ,0x47 ,0xf0 ,0xad ,0xd4 ,0xa2 ,0xaf ,0x9c ,0xa4 ,0x72 ,0xc0
 ,0xb7 ,0xfd ,0x93 ,0x26 ,0x36 ,0x3f ,0xf7 ,0xcc ,0x34 ,0xa5 ,0xe5 ,0xf1 ,0x71 ,0xd8 ,0x31 ,0x15
 ,0x04 ,0xc7 ,0x23 ,0xc3 ,0x18 ,0x96 ,0x05 ,0x9a ,0x07 ,0x12 ,0x80 ,0xe2 ,0xeb ,0x27 ,0xb2 ,0x75
 ,0x09 ,0x83 ,0x2c ,0x1a ,0x1b ,0x6e ,0x5a ,0xa0 ,0x52 ,0x3b ,0xd6 ,0xb3 ,0x29 ,0xe3 ,0x2f ,0x84
 ,0x53 ,0xd1 ,0x00 ,0xed ,0x20 ,0xfc ,0xb1 ,0x5b ,0x6a ,0xcb ,0xbe ,0x39 ,0x4a ,0x4c ,0x58 ,0xcf
 ,0xd0 ,0xef ,0xaa ,0xfb ,0x43 ,0x4d ,0x33 ,0x85 ,0x45 ,0xf9 ,0x02 ,0x7f ,0x50 ,0x3c ,0x9f ,0xa8
 ,0x51 ,0xa3 ,0x40 ,0x8f ,0x92 ,0x9d ,0x38 ,0xf5 ,0xbc ,0xb6 ,0xda ,0x21 ,0x10 ,0xff ,0xf3 ,0xd2
 ,0xcd ,0x0c ,0x13 ,0xec ,0x5f ,0x97 ,0x44 ,0x17 ,0xc4 ,0xa7 ,0x7e ,0x3d ,0x64 ,0x5d ,0x19 ,0x73
 ,0x60 ,0x81 ,0x4f ,0xdc ,0x22 ,0x2a ,0x90 ,0x88 ,0x46 ,0xee ,0xb8 ,0x14 ,0xde ,0x5e ,0x0b ,0xdb
 ,0xe0 ,0x32 ,0x3a ,0x0a ,0x49 ,0x06 ,0x24 ,0x5c ,0xc2 ,0xd3 ,0xac ,0x62 ,0x91 ,0x95 ,0xe4 ,0x79
 ,0xe7 ,0xc8 ,0x37 ,0x6d ,0x8d ,0xd5 ,0x4e ,0xa9 ,0x6c ,0x56 ,0xf4 ,0xea ,0x65 ,0x7a ,0xae ,0x08
 ,0xba ,0x78 ,0x25 ,0x2e ,0x1c ,0xa6 ,0xb4 ,0xc6 ,0xe8 ,0xdd ,0x74 ,0x1f ,0x4b ,0xbd ,0x8b ,0x8a
 ,0x70 ,0x3e ,0xb5 ,0x66 ,0x48 ,0x03 ,0xf6 ,0x0e ,0x61 ,0x35 ,0x57 ,0xb9 ,0x86 ,0xc1 ,0x1d ,0x9e
 ,0xe1 ,0xf8 ,0x98 ,0x11 ,0x69 ,0xd9 ,0x8e ,0x94 ,0x9b ,0x1e ,0x87 ,0xe9 ,0xce ,0x55 ,0x28 ,0xdf
 ,0x8c ,0xa1 ,0x89 ,0x0d ,0xbf ,0xe6 ,0x42 ,0x68 ,0x41 ,0x99 ,0x2d ,0x0f ,0xb0 ,0x54 ,0xbb ,0x16};
 
int isbox[16][16] =
 {0x52 ,0x09 ,0x6a ,0xd5 ,0x30 ,0x36 ,0xa5 ,0x38 ,0xbf ,0x40 ,0xa3 ,0x9e ,0x81 ,0xf3 ,0xd7 ,0xfb
 ,0x7c ,0xe3 ,0x39 ,0x82 ,0x9b ,0x2f ,0xff ,0x87 ,0x34 ,0x8e ,0x43 ,0x44 ,0xc4 ,0xde ,0xe9 ,0xcb
 ,0x54 ,0x7b ,0x94 ,0x32 ,0xa6 ,0xc2 ,0x23 ,0x3d ,0xee ,0x4c ,0x95 ,0x0b ,0x42 ,0xfa ,0xc3 ,0x4e
 ,0x08 ,0x2e ,0xa1 ,0x66 ,0x28 ,0xd9 ,0x24 ,0xb2 ,0x76 ,0x5b ,0xa2 ,0x49 ,0x6d ,0x8b ,0xd1 ,0x25
 ,0x72 ,0xf8 ,0xf6 ,0x64 ,0x86 ,0x68 ,0x98 ,0x16 ,0xd4 ,0xa4 ,0x5c ,0xcc ,0x5d ,0x65 ,0xb6 ,0x92
 ,0x6c ,0x70 ,0x48 ,0x50 ,0xfd ,0xed ,0xb9 ,0xda ,0x5e ,0x15 ,0x46 ,0x57 ,0xa7 ,0x8d ,0x9d ,0x84
 ,0x90 ,0xd8 ,0xab ,0x00 ,0x8c ,0xbc ,0xd3 ,0x0a ,0xf7 ,0xe4 ,0x58 ,0x05 ,0xb8 ,0xb3 ,0x45 ,0x06
 ,0xd0 ,0x2c ,0x1e ,0x8f ,0xca ,0x3f ,0x0f ,0x02 ,0xc1 ,0xaf ,0xbd ,0x03 ,0x01 ,0x13 ,0x8a ,0x6b
 ,0x3a ,0x91 ,0x11 ,0x41 ,0x4f ,0x67 ,0xdc ,0xea ,0x97 ,0xf2 ,0xcf ,0xce ,0xf0 ,0xb4 ,0xe6 ,0x73
 ,0x96 ,0xac ,0x74 ,0x22 ,0xe7 ,0xad ,0x35 ,0x85 ,0xe2 ,0xf9 ,0x37 ,0xe8 ,0x1c ,0x75 ,0xdf ,0x6e
 ,0x47 ,0xf1 ,0x1a ,0x71 ,0x1d ,0x29 ,0xc5 ,0x89 ,0x6f ,0xb7 ,0x62 ,0x0e ,0xaa ,0x18 ,0xbe ,0x1b
 ,0xfc ,0x56 ,0x3e ,0x4b ,0xc6 ,0xd2 ,0x79 ,0x20 ,0x9a ,0xdb ,0xc0 ,0xfe ,0x78 ,0xcd ,0x5a ,0xf4
 ,0x1f ,0xdd ,0xa8 ,0x33 ,0x88 ,0x07 ,0xc7 ,0x31 ,0xb1 ,0x12 ,0x10 ,0x59 ,0x27 ,0x80 ,0xec ,0x5f
 ,0x60 ,0x51 ,0x7f ,0xa9 ,0x19 ,0xb5 ,0x4a ,0x0d ,0x2d ,0xe5 ,0x7a ,0x9f ,0x93 ,0xc9 ,0x9c ,0xef
 ,0xa0 ,0xe0 ,0x3b ,0x4d ,0xae ,0x2a ,0xf5 ,0xb0 ,0xc8 ,0xeb ,0xbb ,0x3c ,0x83 ,0x53 ,0x99 ,0x61
 ,0x17 ,0x2b ,0x04 ,0x7e ,0xba ,0x77 ,0xd6 ,0x26 ,0xe1 ,0x69 ,0x14 ,0x63 ,0x55 ,0x21 ,0x0c ,0x7d
 };
 
int ubah_char(char c)
{
	switch(c) 
	{ 
	case '0' : return 0;
    case '1' : return 1;
    case '2' : return 2;
    case '3' : return 3;
    case '4' : return 4;
    case '5' : return 5;
    case '6' : return 6;
    case '7' : return 7;
    case '8' : return 8;
    case '9' : return 9;
    case 'a' : return 10;
    case 'b' : return 11;
    case 'c' : return 12;
    case 'd' : return 13;
    case 'e' : return 14;
    case 'f' : return 15;
	}
}

char ubah_int(int c)
{
	switch(c) 
	{ 
	case 0 :  return '0';
    case 1 :  return '1';
    case 2 :  return '2';
    case 3 :  return '3';
    case 4 :  return '4';
    case 5 :  return '5';
    case 6 :  return '6';
    case 7 :  return '7';
    case 8 :  return '8';
    case 9 :  return '9';
    case 10 : return 'a';
    case 11 : return 'b';
    case 12 : return 'c';
    case 13 : return 'd';
    case 14 : return 'e';
    case 15 : return 'f';
	}
}

void get_key()
{
	char c;
	ifstream fin;
	fin.open("key.txt");
	for(int i=0; i<4; i++)
		for(int j=0; j<4; j++)
		{
			fin.get(c);
			key.s[i][j]=c;
		}
	fin.close();
}

void key_expan()
{
	int tmp;
	tmp = key.s[0][0];
	key.s[0][0] = key.s[3][0];
	key.s[3][0] = tmp;
	
	for(int j=0; j<4; j++)
	{
		char s[3];
		sprintf(s,"%x\0",key.s[j][0]);
		if(strlen(s)==1)
		{
			s[2]='\0';
			s[1]=s[0];
			s[0]='0';
		}
		key.s[j][0] = sbox[ubah_char(s[0])][ubah_char(s[1])];
	}
	
	for(int k=1; k<4; k++)
		for(int j=0; j<4; j++)
			key.s[j][k] = key.s[j][k] ^ key.s[j][k-1];
}

void print_key()
{
		for(int j=0; j<4; j++)
		{
			for(int k=0; k<4; k++)
				printf("%c ",key.s[j][k]);
			printf("\n");
		}
}

const int overflow = 0x100, modu = 0x11B; 
int gf_mul(int a, int b) {
    int sum = 0;
    while (b > 0) {
        if (b & 1) sum = sum ^ a;             
        b = b >> 1;                           
        a = a << 1;                           
        if (a & overflow) a = a ^ modu;    
    }
    return sum;
}

void init()
{
	// take file to str
	char c;
	string str="";
	ifstream fin;
	fin.open("file.txt");
	while (fin.get(c))
		str+=c;
	fin.close();
	
		// Input blok/Push ke vector
		int c_jum=str.length();
		int b_jum=c_jum/16;
		int sisa = c_jum%16;
		int cnt=0;
		
		for(int i=0; i<b_jum; i++)
		{
			blok b_tmp;
			for(int j=0; j<4; j++)
				for(int k=0; k<4; k++)
				{
					b_tmp.s[j][k]=str[cnt];
					cnt++;
				}
			v_blok.push_back(b_tmp);
		}
		
		if( sisa > 0 )
		{
			blok b_tmp;
			for(int j=0; j<4; j++)
				for(int k=0; k<4; k++)
				{
					if(sisa>0)
					{
						b_tmp.s[j][k]=str[cnt];
						cnt++;
						sisa--;
					}
					else 
					{
						b_tmp.s[j][k]=' ';
					}	
				}
			v_blok.push_back(b_tmp);
		}
}

void sub_column()
{
	// sub column
	for(int i=0; i<v_blok.size(); i++)
		for(int j=0; j<4; j++)
			for(int k=0; k<4; k++)
			{
				char s[3];
				sprintf(s,"%x\0",v_blok[i].s[j][k]);
				if(strlen(s)==1)
				{
					s[2]='\0';
					s[1]=s[0];
					s[0]='0';
				}
				v_blok[i].s[j][k]=sbox[ubah_char(s[0])][ubah_char(s[1])];
			}
}

void inv_sub_column()
{
	// sub column
	for(int i=0; i<v_blok.size(); i++)
		for(int j=0; j<4; j++)
			for(int k=0; k<4; k++)
			{
				char s[3];
				sprintf(s,"%x\0",v_blok[i].s[j][k]);
				if(strlen(s)==1)
				{
					s[2]='\0';
					s[1]=s[0];
					s[0]='0';
				}
				v_blok[i].s[j][k]=isbox[ubah_char(s[0])][ubah_char(s[1])];
			}
}

void shift_row()
{
	// shift row
	for(int i=0; i<v_blok.size(); i++)
	{
		int tmp;
		tmp=v_blok[i].s[1][0];
		v_blok[i].s[1][0] = v_blok[i].s[1][1]; 
		v_blok[i].s[1][1] = v_blok[i].s[1][2]; 
		v_blok[i].s[1][2] = v_blok[i].s[1][3];
		v_blok[i].s[1][3] = tmp;
		
		tmp=v_blok[i].s[2][0];
		v_blok[i].s[2][0] = v_blok[i].s[2][2]; 
		v_blok[i].s[2][2] = tmp; 
		tmp=v_blok[i].s[2][1];
		v_blok[i].s[2][1] = v_blok[i].s[2][3];
		v_blok[i].s[2][3] = tmp;
			
		tmp=v_blok[i].s[3][0];
		v_blok[i].s[3][0] = v_blok[i].s[3][3]; 
		v_blok[i].s[3][3] = v_blok[i].s[3][2]; 
		v_blok[i].s[3][2] = v_blok[i].s[3][1];
		v_blok[i].s[3][1] = tmp;
	}	
}

void mix_column()
{
	int arr_tmp[4];
	
	for(int i=0; i<v_blok.size(); i++)
		for(int k=0; k<4; k++)
		{
			// get row
			for(int z=0; z<4; z++)
				arr_tmp[z] = v_blok[i].s[z][k];
			
			// find each value of column k row j
			for(int j=0; j<4; j++)
			{
				v_blok[i].s[j][k]=
				gf_mul(arr_tmp[0],mix_arr[j][0])^gf_mul(arr_tmp[1],mix_arr[j][1])^
				gf_mul(arr_tmp[2],mix_arr[j][2])^gf_mul(arr_tmp[3],mix_arr[j][3]);
			}
		}
}

void inv_mix_column()
{
	int arr_tmp[4];
	
	for(int i=0; i<v_blok.size(); i++)
		for(int k=0; k<4; k++)
		{
			// get row
			for(int z=0; z<4; z++)
				arr_tmp[z] = v_blok[i].s[z][k];
			
			// find each value of column k row j
			for(int j=0; j<4; j++)
			{
				v_blok[i].s[j][k]=
				gf_mul(arr_tmp[0],inv_mix_arr[j][0])^gf_mul(arr_tmp[1],inv_mix_arr[j][1])^
				gf_mul(arr_tmp[2],inv_mix_arr[j][2])^gf_mul(arr_tmp[3],inv_mix_arr[j][3]);
			}
		}
}

void add_key()
{
	for(int i=0; i<v_blok.size(); i++)
		for(int j=0; j<4; j++)
			for(int k=0; k<4; k++)
				v_blok[i].s[j][k] = v_blok[i].s[j][k] ^ key.s[j][k];
}

void print()
{
	// output tes
	for(int i=0; i<v_blok.size(); i++)
		for(int j=0; j<4; j++)
		{
			for(int k=0; k<4; k++)
				printf("%c ",v_blok[i].s[j][k]);
			printf("\n");
		}
}

int main () {
	init();
	
	print();
	
	add_key();
	for(int i=1; i<=9; i++)
	{
		sub_column();
		shift_row();
		mix_column();
		
		key_expan();
		add_key();
	}
	sub_column();
	shift_row();
	
	key_expan();
	add_key();
	
	print();
  return 0;
}


